---
title: "Rollenspiel Einordnung"
date: 2021-09-20
draft: true
---

<h1>Spider</h1>

<!--
<textarea id="config" style="width: 500px; height: 100px">
{

}
</textarea>
-->

<textarea id="categories" style="width: 500px; height: 200px">
Kategorie 1: 0
Kategorie 2: 1
Kategorie 3: 2
Kategorie 4: 3
Kategorie 5: 2
Kategorie 6: 1
Kategorie 7: 1
Kategorie 8: 1
</textarea>

<canvas id="spider" width="800" height="500">

</canvas>

<!--
<button id="copy">Open Window</button>
-->

<script>

function limit(value, min, max) {
	if (value < min) {
		return min;
	} else if (value > max) {
		return max;
	} else {
		return value;
	}
}

function drawSpider(config, categories) {
	// TODO add settings parameter

	const configMode = 'canvas'; // TODO svg (svg disadvantage: create png image)
	const configID = config.id;
	const configSegments = 5;
	const configFont = config.font ?? '15pt Lato'; // TODO auto?
	const configTextDistance = 10;
	const configLineWidth = 2;
	const configGridStroke = '#333';
	const configAreaStroke = '#66f';
	const configAreaFill = '#66f3';
	const configBackgroundFill = 'transparent';
	const configTextFill = '#300';
	const configBorder = 10;

	const sides = categories.length;
	const canvas = document.getElementById(configID);
	const style = window.getComputedStyle(canvas);
	const ctx = canvas.getContext('2d');
	const width = canvas.width;
	const height = canvas.height;
	const centerX = width / 2;
	const centerY = height / 2;

	if (configFont === 'auto') {
		// TODO
		//ctx.font = style.fontFamily;
	} else {
		ctx.font = configFont;
	}

	const metrics = ctx.measureText(categories[0][0]);
	const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;

	const radiusMax = Math.min(centerX, centerY) - (configTextDistance + textHeight + configBorder);

	const angle360Deg = 2 * Math.PI;
	const angle90Deg = angle360Deg / 4;
	const angle270Deg = 3 * angle90Deg;
	const angleEpsilon = 0.2;

	const segments = configSegments;
	const angleStep = angle360Deg / sides;

	ctx.clearRect(0, 0, width, height);
	ctx.fillStyle = configBackgroundFill;
	ctx.fillRect(0, 0, width, height);

	/*
	Because of the default canvas coordinate system, the angle calculation also
	produces coordinates which are upside-down. E.g. 90Â° is a the bottom.
	*/

	ctx.fillStyle = configTextFill;
	ctx.save();
	ctx.translate(centerX, centerY);
	for (let side = 0; side < sides; side += 1) {
		const angle = side * angleStep;
		const radius = radiusMax + configTextDistance;
		const x = Math.cos(angle) * radius;
		const y = Math.sin(angle) * radius;
		if (Math.abs(angle - angle270Deg) < angleEpsilon) {
			// top
			ctx.textAlign = 'center';
			ctx.textBaseline = 'bottom';
		} else if(Math.abs(angle - angle90Deg) < angleEpsilon) {
			// bottom
			ctx.textAlign = 'center';
			ctx.textBaseline = 'top';
		} else if((angle > angle90Deg) && (angle < angle270Deg)) {
			// left
			ctx.textAlign = 'right';
			ctx.textBaseline = 'middle';
		} else {
			// right
			ctx.textAlign = 'left';
			ctx.textBaseline = 'middle';
		}
		ctx.fillText(categories[side][0], x, y);
	}

	ctx.lineWidth = configLineWidth;
	ctx.strokeStyle = configGridStroke;
	for (let segment = 0; segment < segments; segment += 1) {
		const radius = ((segment + 1) / segments) * radiusMax;
		ctx.beginPath();
		for (let side = 0; side < sides; side += 1) {
			const angle = side * angleStep;
			const x = Math.cos(angle) * radius;
			const y = Math.sin(angle) * radius;
			ctx.lineTo(x, y);
		}
		ctx.closePath();
		ctx.stroke();
	}
	ctx.beginPath();
	for (let side = 0; side < sides; side += 1) {
		const angle = side * angleStep;
		const x = Math.cos(angle) * radiusMax;
		const y = Math.sin(angle) * radiusMax;
		ctx.moveTo(0, 0);
		ctx.lineTo(x, y);
	}
	ctx.stroke();

	ctx.strokeStyle = configAreaStroke;
	ctx.fillStyle = configAreaFill;
	ctx.beginPath();
	for (let side = 0; side < sides; side += 1) {
		const angle = side * angleStep;
		const segment = limit(categories[side][1], 0, segments - 1);
		const r = ((segment + 1) / segments) * radiusMax;
		const x = Math.cos(angle) * r;
		const y = Math.sin(angle) * r;
		ctx.lineTo(x, y);
	}
	ctx.closePath();
	ctx.fill();
	ctx.stroke();

	ctx.restore();
}

function run() {
	function draw() {
		const categoriesString = document.getElementById('categories').value;
		const categories = [];
		categoriesString.split('\n').forEach(line => {
			if (line.includes(':')) {
				const elements = line.split(':', 2);
				const keyMaybe = elements[0].trim();
				const valueMaybe = parseInt(elements[1]);
				const key = typeof keyMaybe === 'string' ? keyMaybe : '?';
				const value = Number.isInteger(valueMaybe) ? valueMaybe : 0;
				categories.push([key, value]);
			}
		});
		drawSpider({id: 'spider', font: '20pt Ubuntu'}, categories);
	}

	document.getElementById('categories').addEventListener('input', draw);
	draw();

	/*
	document.getElementById('copy').addEventListener('click', () => {
		const canvas = document.getElementById('spider');
		const png = canvas.toDataURL('image/png');
		// https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API
		window.open(png);
		// open window?
	});
	*/
}

run();

</script>
